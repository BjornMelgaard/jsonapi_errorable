{
  "name": "Jsonapi errorable",
  "tagline": "",
  "body": "### jsonapi_errorable\r\n\r\nGlobal error handling compatible with [the jsonapi.org spec](http://jsonapi.org/format/#errors)\r\n\r\n### Installation\r\n\r\nAdd to your ApplicationController:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  include JsonapiErrorable\r\n\r\n  rescue_from Exception do |e|\r\n    handle_exception(e)\r\n  end\r\nend\r\n```\r\n\r\n**Note**: This gem requires `active_model_serializers`, which overrides `render`.\r\n\r\n### Global Error Handling\r\n\r\nOnce installed, all errors will return a valid error response. `raise \"foo\"` would render:\r\n\r\n```ruby\r\n{\r\n  errors: [\r\n    code: 'internal_server_error',\r\n    status: '500',\r\n    title: 'Error',\r\n    detail: \"We've notified our engineers and hope to address this issue shortly.\",\r\n    meta: {}\r\n  ]\r\n}\r\n```\r\n\r\n### Validation Error Handling\r\n\r\nGiven a record fails [validations](http://api.rubyonrails.org/classes/ActiveModel/Validations.html), you probably want to render a custom error message specific to the validation failure. Use `render_errors_for`:\r\n\r\n```ruby\r\ndef create\r\n  post = Post.new(post_params)\r\n\r\n  if post.save\r\n    render json: post\r\n  else\r\n    render_errors_for(post)\r\n  end\r\nend\r\n```\r\n\r\nAssuming the Post's `title` was missing, this would render:\r\n\r\n```ruby\r\n{\r\n  errors: [\r\n    {\r\n      code: 'unprocessable_entity',\r\n      status: '422',\r\n      title: 'Validation Error',\r\n      detail: \"Title can't be blank\",\r\n      source: { pointer: '/data/attributes/title' },\r\n      meta: { attribute: 'title', message: \"can't be blank\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### Customizing Error Responses\r\n\r\nYou can customize an error's response by using `register_exception` in your controller. Let's say we want `ActiveRecord::RecordNotFound` to have status code `404` instead of `500`:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  # ...installation code...\r\n  register_exception ActiveRecord::RecordNotFound, status: 404\r\nend\r\n```\r\n\r\nWould now render http status code `404`, with the error JSON containing `status: '404'` and `code: 'not_found'`.\r\n\r\nAvailable options are:\r\n\r\n* `status`: An http status code\r\n* `title`: Custom title\r\n* `log`: Pass `false` to avoid logging the error\r\n* `message`: Pass `true` to render the error's message directly. Alternatively, this can accept a proc, e.g. `register_exception FooError, message: ->(e) { e.message.upcase }`\r\n\r\n### Custom Exception Handler\r\n\r\nThe final option `register_exception` accepts is `handler`. Here you can inject your own error handling class that customizes [JsonapiErrorable::ExceptionHandler](https://bbgithub.dev.bloomberg.com/InfrastructureExperience/jsonapi_errorable/blob/master/lib/jsonapi_errorable/exception_handler.rb). For example:\r\n\r\n```ruby\r\nclass MyCustomHandler < JsonapiErrorable::ExceptionHandler\r\n  def status_code(error)\r\n    # ...customize...\r\n  end\r\n\r\n  def error_code(error)\r\n    # ...customize...\r\n  end\r\n\r\n  def title\r\n    # ...customize...\r\n  end\r\n\r\n  def detail(error)\r\n    # ...customize...\r\n  end\r\n\r\n  def meta(error)\r\n    # ...customize...\r\n  end\r\n\r\n  def log(error)\r\n    # ...customize...\r\n  end\r\nend\r\n\r\nregister_exception FooError, handler: MyCustomHandler\r\n```\r\n\r\nIf you would like to use the same custom handler for all errors, override `default_exception_handler`:\r\n\r\n```ruby\r\n# app/controllers/application_controller.rb\r\ndef self.default_exception_handler\r\n  MyCustomHandler\r\nend\r\n```\r\n\r\n### Exception Handling in Subclasses\r\n\r\nAll controllers will inherit any registered exceptions from their parent. They can also add their own. In this example, `FooError` will only throw a custom status code when thrown from `FooController`:\r\n\r\n```ruby\r\nclass FooController < ApplicationController\r\n  register_exception FooError, status: 422\r\nend\r\n```\r\n\r\n### Custom Logger\r\n\r\nYou can assign any logger using `JsonapiErrorable.logger = your_logger`\r\n\r\n### Within Tests\r\n\r\nYou may want your tests to actually raise errors instead of returning error JSON. In this case use `disabled!` and `enabled`:\r\n\r\n```ruby\r\nbefore :each do\r\n  JsonapiErrorable.disabled!\r\nend\r\n\r\nit 'renders correct error response' do\r\n  JsonapiErrorable.enabled! # enabled just for this test\r\nend\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}